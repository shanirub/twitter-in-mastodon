import { False, True, And, Or, Not } from './conditionals';
/** no-doc */
export declare type KnownProblemPrototypeKeys = 'toString' | 'toLocaleString' | 'hasOwnProperty' | 'isPrototypeOf' | 'propertyIsEnumerable' | 'constructor' | 'valueOf';
/** no-doc */
export declare type ArrayPrototypeKeys = keyof unknown[];
/** no-doc */
export declare type NumberPrototypeKeys = keyof number;
/** no-doc */
export declare type BooleanPrototypeKeys = keyof false;
/** no-doc */
export declare type StringPrototypeKeys = keyof string;
/** no-doc */
export declare type ObjectPrototypeKeys = keyof Object;
/** no-doc */
export declare type FunctionPrototypeKeys = keyof Function;
export declare type IsNever<S extends string> = Not<(Record<S, True> & Record<string, False>)[S]>;
export declare type IsType<T, X> = X extends T ? True : False;
export declare type IsArray<T> = T extends unknown[] ? True : False;
export declare type IsNumber<T> = T extends number ? True : False;
export declare type IsString<T> = T extends string ? True : False;
export declare type IsFunction<T> = Or<T extends Function ? True : False, T extends Function ? True : False>;
export declare type IsStringFunction<T extends string> = And<IsString<T>, IsNever<T>>;
export declare type IsBoolean<T> = T extends boolean ? True : False;
export declare type IsNull<T> = T extends null ? True : False;
export declare type IsUndefined<T> = T extends undefined ? True : False;
export declare type IsNil<T> = Or<IsNull<T>, IsUndefined<T>>;
export declare type IsObject<T> = And<T extends object ? True : False, And<Not<IsFunction<T>>, Not<IsArray<T>>>>;
export declare type IsAny<T> = And<Not<IsArray<T>>, And<Not<IsBoolean<T>>, And<Not<IsNumber<T>>, And<Not<IsString<T>>, And<Not<IsFunction<T>>, And<Not<IsNil<T>>, Not<IsObject<T>>>>>>>>;
