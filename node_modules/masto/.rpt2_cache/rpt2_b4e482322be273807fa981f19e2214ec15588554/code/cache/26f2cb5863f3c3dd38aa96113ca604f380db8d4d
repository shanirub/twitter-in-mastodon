{"code":"import * as tslib_1 from \"tslib\";\r\n// tslint:disable no-unnecessary-override\r\nimport * as EventEmitter from 'eventemitter3';\r\nimport * as WebSocket from 'isomorphic-ws';\r\n/**\r\n * Mastodon streaming api wrapper\r\n */\r\nvar MastoEvents = /** @class */ (function (_super) {\r\n    tslib_1.__extends(MastoEvents, _super);\r\n    function MastoEvents() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /**\r\n         * Parse JSON data and emit it as an event\r\n         * @param message Websocket message\r\n         */\r\n        _this.handleMessage = function (message) {\r\n            if (message.type !== 'utf8') {\r\n                return;\r\n            }\r\n            var parsedMessage = JSON.parse(message.data);\r\n            try {\r\n                parsedMessage.data = JSON.parse(parsedMessage.payload);\r\n            }\r\n            catch (_a) {\r\n                // If parsing failed, returns raw data\r\n                // Basically this is handling for `filters_changed` event\r\n                // Which doesn't contain payload in the data\r\n                parsedMessage.data = parsedMessage.payload;\r\n            }\r\n            // Remove original payload\r\n            delete parsedMessage.payload;\r\n            _this.emit(parsedMessage.event, parsedMessage);\r\n        };\r\n        return _this;\r\n    }\r\n    /**\r\n     * Connect to the websocket endpoint\r\n     * @param url URL of the websocket endpoint\r\n     * @param params URL parameters\r\n     */\r\n    MastoEvents.prototype.connect = function (url) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.ws = new WebSocket(url);\r\n            _this.ws.addEventListener('message', _this.handleMessage);\r\n            _this.ws.addEventListener('error', reject);\r\n            _this.ws.addEventListener('open', function () {\r\n                resolve(_this);\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Disconnect from the websocket endpoint\r\n     */\r\n    MastoEvents.prototype.disconnect = function () {\r\n        if (!this.ws)\r\n            return;\r\n        this.ws.close();\r\n    };\r\n    /**\r\n     * Add listener for the event\r\n     * @param event Type of the event. One of `update`, `delete`, `notification`, `filters_changed`, `conversation`\r\n     * @param callback Callback function\r\n     */\r\n    MastoEvents.prototype.on = function (event, callback) {\r\n        return _super.prototype.on.call(this, event, callback);\r\n    };\r\n    return MastoEvents;\r\n}(EventEmitter));\r\nexport { MastoEvents };\r\n","dts":{"name":"/Users/nucx/Developments/masto.js/client/masto-events.d.ts","writeByteOrderMark":false,"text":"/// <reference types=\"ws\" />\r\nimport * as EventEmitter from 'eventemitter3';\r\nimport * as WebSocket from 'isomorphic-ws';\r\nimport { Conversation } from '../entities/conversation';\r\nimport { Notification } from '../entities/notification';\r\nimport { Status } from '../entities/status';\r\n/** Callback argument of `ws` */\r\nexport interface Message {\r\n    data: any;\r\n    type: string;\r\n    target: WebSocket;\r\n}\r\nexport interface EventTypesMap {\r\n    /** Status posted */\r\n    update: Status;\r\n    /** Status deleted */\r\n    delete: Status['id'];\r\n    /** User's notification */\r\n    notification: Notification;\r\n    /** User's filter changed */\r\n    filters_changed: undefined;\r\n    /** Status added to a conversation */\r\n    conversation: Conversation;\r\n}\r\nexport declare type EventTypes = keyof EventTypesMap;\r\nexport interface Event<T extends EventTypes = EventTypes> {\r\n    /** Event type */\r\n    event: T;\r\n    /** Parsed payload data */\r\n    data: EventTypesMap[T];\r\n}\r\n/**\r\n * Mastodon streaming api wrapper\r\n */\r\nexport declare class MastoEvents extends EventEmitter {\r\n    private ws?;\r\n    /**\r\n     * Connect to the websocket endpoint\r\n     * @param url URL of the websocket endpoint\r\n     * @param params URL parameters\r\n     */\r\n    connect(url: string): Promise<MastoEvents>;\r\n    /**\r\n     * Disconnect from the websocket endpoint\r\n     */\r\n    disconnect(): void;\r\n    /**\r\n     * Parse JSON data and emit it as an event\r\n     * @param message Websocket message\r\n     */\r\n    handleMessage: (message: Message) => void;\r\n    /**\r\n     * Add listener for the event\r\n     * @param event Type of the event. One of `update`, `delete`, `notification`, `filters_changed`, `conversation`\r\n     * @param callback Callback function\r\n     */\r\n    on<T extends EventTypes>(event: T, callback: (payload: Event<T>) => void): this;\r\n}\r\n"}}
